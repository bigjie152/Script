import { promises as fs } from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const scriptDir = path.dirname(fileURLToPath(import.meta.url));
const rootDir = path.resolve(scriptDir, "..");
const promptsDir = path.join(rootDir, "packages", "prompts");
const targetFile = path.join(rootDir, "apps", "web", "lib", "prompts.ts");

async function listPromptFiles(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files = [];
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...(await listPromptFiles(fullPath)));
    } else if (entry.isFile() && entry.name.endsWith(".md")) {
      files.push(fullPath);
    }
  }
  return files;
}

function normalizePath(value) {
  return value.split(path.sep).join("/");
}

async function run() {
  const files = await listPromptFiles(promptsDir);
  files.sort();
  const entries = [];
  for (const file of files) {
    if (path.basename(file).toLowerCase() === "readme.md") {
      continue;
    }
    const relative = normalizePath(path.relative(promptsDir, file));
    const content = await fs.readFile(file, "utf8");
    const normalized = content.replace(/\r\n/g, "\n");
    entries.push([relative, normalized]);
  }

  const promptMap = Object.fromEntries(entries);
  const output = `// This file is auto-generated by scripts/sync-prompts.mjs.
// Source: packages/prompts/**/*.md

const PROMPTS: Record<string, string> = ${JSON.stringify(promptMap, null, 2)};

export async function loadPrompt(relativePath: string) {
  const key = relativePath.replace(/^[\\\\/]+/, "");
  return PROMPTS[key] || "";
}
`;

  await fs.writeFile(targetFile, output, "utf8");
  const relTarget = normalizePath(path.relative(rootDir, targetFile));
  console.log(`[sync-prompts] wrote ${entries.length} prompts -> ${relTarget}`);
}

run().catch((err) => {
  console.error("[sync-prompts] failed", err);
  process.exit(1);
});
